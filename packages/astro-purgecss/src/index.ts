import type { AstroConfig, AstroIntegration } from 'astro';
import { existsSync } from 'node:fs';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { PurgeCSS, type UserDefinedOptions } from 'purgecss';

import {
  generateFileHash,
  readFileContent,
  success,
  writeCssFile,
  writeFileContent
} from './utils';

export interface PurgeCSSOptions extends Partial<UserDefinedOptions> {}

const PKG_NAME = 'astro-purgecss' as const;

function Plugin(options: PurgeCSSOptions = {}): AstroIntegration {
  let config: AstroConfig;
  return {
    name: PKG_NAME,
    hooks: {
      'astro:config:done': ({ config: cfg }) => {
        config = cfg;
      },
      'astro:build:done': async ({ dir, pages, logger }) => {
        const outDir = fileURLToPath(dir);

        if (!outDir || !config.build.format || !config.build.assets) {
          logger.warn(
            `${PKG_NAME} requires the 'outDir', 'build.format', 'build.assets' astro.config options.`
          );
          return;
        }

        logger.info('Generating purged css files...');
        const purged = await new PurgeCSS().purge({
          css: [join(outDir, '/**/*.css')],
          defaultExtractor: (content) => content.match(/[\w-/:]+(?<!:)/g) || [],
          ...options,
          content: [
            join(outDir, '/**/*.html'),
            join(outDir, '/**/*.js'),
            ...(options.content || [])
          ]
        });

        let purgedCssFiles = await Promise.all(
          purged
            .filter(({ file }) => file?.endsWith('.css'))
            .map(async ({ css, file }) => {
              const oldFile = file as string;

              // skip rehashing file if not generated by astro ex: assets/styles/light.css
              if (!oldFile.includes(config.build.assets)) {
                await writeCssFile(oldFile, css, oldFile);
                success(oldFile.replace(outDir, ''));
                return {
                  oldFilename: oldFile.replace(outDir, ''),
                  newFilename: oldFile.replace(outDir, '')
                };
              }

              // Generate new hash based on content
              const newFile = generateFileHash(oldFile, css);

              // Write new file
              await writeCssFile(newFile, css, oldFile);
              success(newFile.replace(outDir, ''));

              return {
                oldFilename: oldFile.replace(outDir, ''),
                newFilename: newFile.replace(outDir, '')
              };
            })
        );

        // Filter out unchanged files: keep only files where content was modified and rehashed
        // This ensures we only process files that actually changed during purging
        purgedCssFiles = purgedCssFiles.filter(
          ({ oldFilename, newFilename }) => oldFilename !== newFilename
        );

        if (purgedCssFiles.length > 0) {
          logger.info('Updating css references in html files...');
          const htmlPages = pages
            .filter((e: any) => typeof e.pathname == 'string')
            // see: https://docs.astro.build/en/reference/configuration-reference/#buildformat
            .map((page) => {
              // Special case: Handle root/index page
              if (page.pathname === '') return join(outDir, `index.html`);

              // Build format:
              // 'file' - Astro will generate an HTML file named for each page route
              if (config.build.format === 'file') {
                return join(outDir, `${page.pathname}.html`);
              }

              // Build format:
              // 'directory' - Astro will generate a directory with a nested index.html file for each page
              if (config.build.format === 'directory') {
                return join(outDir, page.pathname, 'index.html');
              }

              // Build format:
              // 'preserve' - Maintains existing structure or falls back to directory format

              // Check if an HTML file already exists at the target location
              if (existsSync(join(outDir, `${page.pathname}.html`))) {
                return join(outDir, `${page.pathname}.html`);
              }

              // Default: Use directory format
              return join(outDir, page.pathname, 'index.html');
            });

          await Promise.all(
            htmlPages.map(async (page) => {
              let content = await readFileContent(page);

              for (const cssFile of purgedCssFiles) {
                if (content.includes(cssFile.oldFilename)) {
                  content = content.replace(
                    new RegExp(cssFile.oldFilename, 'g'),
                    cssFile.newFilename
                  );
                }
              }
              await writeFileContent(page, content);
              success(page.replace(outDir, ''));
            })
          );
        } else {
          logger.info('No CSS files were modified during purging.');
        }

        logger.info('completed successfully!');
      }
    }
  };
}

export default Plugin;
